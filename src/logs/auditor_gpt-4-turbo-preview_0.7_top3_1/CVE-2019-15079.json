[
    {
        "function_name": "_transfer",
        "code": "function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }",
        "vulnerability": "Unchecked return value",
        "reason": "Although the function correctly checks preconditions and updates balances, it does not check the return value of the internal 'transfer' call for external contracts. This could potentially allow a call to a malicious contract that always fails, preventing the transfer from completing but not reverting the transaction, leading to discrepancies.",
        "file_name": "2019-15079.sol",
        "label": "Typo Constructor",
        "description": "A typo exists in the constructor of a smart contract implementation for EAI through 2019-06-05, an Ethereum token. This vulnerability could be used by an attacker to acquire EAI tokens for free."
    },
    {
        "function_name": "burn",
        "code": "function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit Burn(msg.sender, _value); return true; }",
        "vulnerability": "No validation on burn address",
        "reason": "The 'burn' function decreases the totalSupply, but it does not validate if the '_value' to be burned is being sent to a 'burn' address or just subtracted from the user\u2019s balance without actual asset destruction. This can lead to a situation where tokens are considered 'burned' but still exist in the user's balance, potentially causing a discrepancy in the total supply calculation.",
        "file_name": "2019-15079.sol",
        "label": "Typo Constructor",
        "description": "A typo exists in the constructor of a smart contract implementation for EAI through 2019-06-05, an Ethereum token. This vulnerability could be used by an attacker to acquire EAI tokens for free."
    },
    {
        "function_name": "transferFrom",
        "code": "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; }",
        "vulnerability": "Reentrancy",
        "reason": "The function first decreases the allowance and then performs the token transfer. If the '_transfer' function calls an external contract (via a token receiver contract, for example), it can lead to reentrancy where the external contract calls back into 'transferFrom' before the first transaction completes. This could potentially allow an attacker to transfer more tokens than they are allowed if the external call to '_transfer' can manipulate allowance in the middle of its execution.",
        "file_name": "2019-15079.sol",
        "label": "Typo Constructor",
        "description": "A typo exists in the constructor of a smart contract implementation for EAI through 2019-06-05, an Ethereum token. This vulnerability could be used by an attacker to acquire EAI tokens for free."
    }
]