[
    {
        "function_name": "AddTicket",
        "code": "function AddTicket() public payable { require(msg.value == ticketPrice); require(numtickets < maxTickets); lastTicketTime = now; numtickets += 1; totalBounty += ticketPrice; bool success = numtickets == maxTickets; NewTicket(msg.sender, success); if(success) { PayWinner(msg.sender); } }",
        "vulnerability": "Reentrancy",
        "reason": "In the AddTicket function, if the condition numtickets == maxTickets is met, it calls PayWinner function which eventually sends ether to an external address (winner). This operation is susceptible to reentrancy attack because the state changes (e.g., numtickets, totalBounty reset) occur after the external call. An attacker could recursively call AddTicket in the fallback function during the transfer, leading to unexpected behavior before the state variables are reset.",
        "file_name": "2018-15552.sol",
        "label": "Bad Randomness",
        "description": "The \"PayWinner\" function of a simplelottery smart contract implementation for The Ethereum Lottery, an Ethereum gambling game, generates a random value with publicly readable variable \"maxTickets\" (which is private, yet predictable and readable by the eth.getStorageAt function). Therefore, it allows attackers to always win and get rewards."
    },
    {
        "function_name": "withdraw",
        "code": "function withdraw() public { require(worldOwner == msg.sender); lottoIndex += 1; numtickets = 0; totalBounty = 0; worldOwner.transfer(this.balance); }",
        "vulnerability": "DoS with (unexpected) revert",
        "reason": "In the withdraw function, the contract transfers all its balance to the worldOwner address. If the call to worldOwner.transfer fails (e.g., the worldOwner address is a contract that reverts on receiving ether), the entire transaction is reverted. This behavior could lock funds indefinitely, as a malicious owner could purposefully set the owner address to a contract designed to fail, preventing the withdrawal of funds.",
        "file_name": "2018-15552.sol",
        "label": "Bad Randomness",
        "description": "The \"PayWinner\" function of a simplelottery smart contract implementation for The Ethereum Lottery, an Ethereum gambling game, generates a random value with publicly readable variable \"maxTickets\" (which is private, yet predictable and readable by the eth.getStorageAt function). Therefore, it allows attackers to always win and get rewards."
    },
    {
        "function_name": "PayWinner",
        "code": "function PayWinner( address winner ) private { require(numtickets == maxTickets); uint ownerTax = 6 * totalBounty / 100; uint winnerPrice = totalBounty - ownerTax; LottoComplete(msg.sender, lottoIndex, winnerPrice); lottoIndex += 1; numtickets = 0; totalBounty = 0; if(_direction == 0 && maxTickets < 20) maxTickets += 1; if(_direction == 1 && maxTickets > 10) maxTickets -= 1; if(_direction == 0 && maxTickets == 20) _direction = 1; if(_direction == 1 && maxTickets == 10) _direction = 0; worldOwner.transfer(ownerTax); winner.transfer(winnerPrice); }",
        "vulnerability": "Integer Overflow and Underflow",
        "reason": "The calculation of ownerTax and winnerPrice in the PayWinner function does not account for potential overflows or underflows. Since Solidity versions before 0.8.0 do not automatically check for these conditions, operations like 'totalBounty - ownerTax' could underflow if totalBounty is less than ownerTax. Although unlikely in this specific context due to controlled inputs, this represents a general security risk and could be exploited in related scenarios where inputs are not as controlled.",
        "file_name": "2018-15552.sol",
        "label": "Bad Randomness",
        "description": "The \"PayWinner\" function of a simplelottery smart contract implementation for The Ethereum Lottery, an Ethereum gambling game, generates a random value with publicly readable variable \"maxTickets\" (which is private, yet predictable and readable by the eth.getStorageAt function). Therefore, it allows attackers to always win and get rewards."
    }
]